# 1) Перец (pepper) при хранении паролей — подробности

### Кратко — идея

**Salt** — уникальная, публичная для каждой записи случайная строка, которая хранится рядом с хэшем.
**Pepper** — секретная константа (или секрет на уровне приложения), которую не хранит БД и знает только сервер (или секретный менеджер). Pepper добавляют в пароль перед хэшированием, чтобы усложнить атаку при утечке базы данных.

### Почему pepper полезен

* Если база данных с хэшами и солью утекла, но pepper остался секретным — атакующий не сможет быстро использовать rainbow tables или precomputed GPU-атаки, потому что для генерации соответствующих хэшей нужен pepper.
* Pepper даёт дополнительный «уровень» защиты для всей системы (не для каждого пользователя отдельно).

### Как применять pepper: варианты

1. **Конкатенация** (простая): `hash( salt + password + pepper )`
2. **HMAC-style**: `HMAC(pepper, salt + password)` или `HMAC(pepper, password)` плюс затем пароль проходит через KDF (bcrypt/argon2).
3. **Двойное хеширование**: сначала стандартный хеш (соль + password), затем подпись/хеш с pepper.

Из них предпочтительнее использовать **pepper как HMAC-ключ** или добавлять его в качестве дополнительного секретного материала в вход KDF. Главное — не полагаться на pepper как на единственную меру.

### Где хранить pepper

* **Никогда** не в БД рядом с хэшами.
* В конфигурации окружения вне репозитория (environment variable), или ещё лучше — в секретном менеджере (HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager, Azure Key Vault).
* В production: секретный менеджер с ограничением доступа + аудит.

### Как выбрать формат и область действия

* Pepper обычно глобальный для приложения (один secret per env). Можно иметь несколько pepper’ов по средам (dev/stage/prod).
* Можно иметь *несколько* pepper’ов (active + previous) для ротации — см. ниже.

### Ротация pepper (смена)

1. **Проблема:** pepper нельзя просто «пересчитать» для уже сохранённых хэшей без знания исходных паролей.
2. **Решения:**

   * **Ленивая (lazy) ротация:** при следующем логине пользователя, если проверка прошла с помощью старого pepper, пересчитать хэш с новым pepper и сохранить. Требуется уметь проверять с использованием старого и нового pepper’ов.
   * **Принудительная миграция:** вынудить всех сменить пароль (например, при утечке pepper) — радикально, но чисто.
3. **Хранение нескольких pepper’ов:** в секрет-хранилище оставить массив [current_pepper, previous_pepper,...], при верификации пробовать по очереди, при успешной проверке пересчитать и сохранить хэш с current_pepper.

### Противопоказания / ограничения

* Если attacker получил и БД, и pepper — защита теряется. Pepper лишь повышает барьер при компрометации только БД.
* Pepper усложняет операции восстановления/массовой миграции, если нет механизма lazy-rehash.
* Pepper не заменяет соль и современные KDF (argon2/bcrypt).

### Практическая рекомендация

* Используйте современный KDF (Argon2/bcrypt) + соль (по-пользовательская) + опциональный pepper (хранить в секретном менеджере).
* Реализация: лучше использовать **pepper в виде секретного ключа для HMAC**, а затем хранить получившийся хеш как обычно (или встраивать pepper в вход KDF).

#### Пример (python, упрощённо):

```python
import os, hmac, hashlib
from passlib.hash import bcrypt

PEPPER = os.environ["PEPPER"]  # хранится в Vault/ENV

def hash_password(password, salt):        # salt — per-user, хранится в DB
    # подпишем password+salt с помощью pepper (HMAC), затем отдадим в bcrypt
    msg = (salt + password).encode()
    keyed = hmac.new(PEPPER.encode(), msg, hashlib.sha256).digest()
    return bcrypt.hash(keyed)            # bcrypt сам генерит соль и возвращает форматированный хэш

def verify_password(stored_hash, password, salt):
    msg = (salt + password).encode()
    keyed = hmac.new(PEPPER.encode(), msg, hashlib.sha256).digest()
    return bcrypt.verify(keyed, stored_hash)
```

---

# 2) Миграции хэшей паролей — как понять, по какому алгоритму проверять и как мигрировать

### Основная задача

У нас в БД — старые записи, где пароли хранятся в устаревшем формате (например MD5), и мы внедряем новый безопасный формат (bcrypt/argon2). Нужно обеспечить, чтобы:

* существующие пользователи могли логиниться до/после миграции,
* новые пароли хранились по-новому,
* со временем все пароли были обновлены.

### Возможные подходы ( и их плюсы/минусы )

1. **Хранить явный флаг/колонку (например `password_version` или `migrated`)**

   * * простая логика: если `password_version = 1` — проверяем старым способом; если 2 — новым.
   * − нужно управлять этой колонкой при каждой операции (риски рассинхронизации).
   * − если у вас смешанные форматы или вы используете сторонние хэш-форматы (bcrypt, argon2), дублирование информации не всегда нужно.

2. **Хранить в поле `password_hash` форматированный хэш, который сам содержит идентификатор алгоритма**

   * Многие KDF/библиотеки (bcrypt, argon2, passlib) возвращают форматированный хэш с префиксом, например:

     * bcrypt: `$2b$12$...`
     * argon2: `$argon2id$...`
   * Тогда **по форме/префиксу** можно однозначно понять алгоритм и выбрать проверку.
   * * не нужно отдельной колонки.
   * Рекомендуется.

3. **Использовать `CryptContext` (passlib) или аналог — и его `needs_update`**

   * `passlib.context.CryptContext` умеет:

     * верифицировать хэш любого поддерживаемого формата (`verify`)
     * сказать, нужен ли rehash к текущему стандарту (`needs_update`)
   * Это самый удобный способ: при логине — `verify`+`needs_update` => если `needs_update` True, то пересчитать и записать новый хэш.
   * * минимальный код, надёжная детекция.
   * Рекомендуется при Python.

4. **Определять алгоритм по паттерну/длине хэша**

   * Простой детект: если поле совпадает с regex `$2[aby]\$` — bcrypt, если 32 hex — возможно MD5 и т.д.
   * Работает, но менее надёжен, чем схемы с явными префиксами.

5. **Принудительная миграция (force)**

   * Сгенерировать для всех пользователей временные пароли/ссылки на сброс пароля — заставить сменить.
   * * чисто и безопасно, но раздражает пользователей.

6. **Lazy rehash (на лету при логине) — наиболее популярный подход**

   * При логине:

     1. Получаем `stored_hash`.
     2. Определяем алгоритм (по префиксу или колонке).
     3. Проверяем пароль соответствующей процедурой.
     4. Если проверка успешна и `stored_hash` не соответствует `current_scheme`, пересчитываем хэш новым способом и обновляем запись в БД.
   * * нет принудительных действий со стороны пользователей.
   * − занимает время при первом логине (нужно делать атомарно).

### Рекомендованная схема таблицы пользователей (простая)

```sql
users (
  id SERIAL PRIMARY KEY,
  email TEXT UNIQUE,
  password_hash TEXT NOT NULL,   -- содержит форматированный хэш с префиксом (bcrypt/argon2/...)
  salt TEXT NULL,                -- если используете внешний salt; обычно не нужен с bcrypt
  password_updated_at TIMESTAMP,
  -- опционально: password_version INTEGER
)
```

(Если используете passlib/bcrypt, per-user salt включается в формат хэша и отдельный столбец salt не нужен.)

### Конкретный алгоритм (примерный код, python + passlib)

```python
from passlib.context import CryptContext
pwd_ctx = CryptContext(schemes=["argon2", "bcrypt", "sha256_crypt", "md5_crypt"],
                      deprecated=["md5_crypt", "sha256_crypt"])
# current preferred scheme — argon2 (помещён первым)

def verify_and_upgrade(user, plain_password, db_session):
    stored_hash = user.password_hash

    # 1) Verify password (passlib поддерживает множество форматов)
    try:
        verified = pwd_ctx.verify(plain_password, stored_hash)
    except Exception:
        return False

    if not verified:
        return False

    # 2) Проверим, нужен ли rehash в текущем контексте
    if pwd_ctx.needs_update(stored_hash):
        # пересчёт и атомарное обновление
        new_hash = pwd_ctx.hash(plain_password)
        user.password_hash = new_hash
        user.password_updated_at = datetime.utcnow()
        db_session.commit()

    return True
```

Пояснения:

* `pwd_ctx.verify` сам определит формат `stored_hash` и выберет соответствующий алгоритм.
* `needs_update` вернёт True, если `stored_hash` не соответствует текущей политике (например, deprecated md5_crypt).
* Это реализует **lazy upgrade**.

### Альтернативный пример без passlib — детекция по префиксу

```python
def algorithm_from_hash(h):
    if h.startswith("$2a$") or h.startswith("$2b$") or h.startswith("$2y$"):
        return "bcrypt"
    if h.startswith("$argon2"):
        return "argon2"
    if len(h) == 32 and all(c in hexdigits for c in h):
        return "md5"
    # ...
```

Затем ветвите: если `md5` — проверить md5(password) == stored_hash, и при успехе пересчитать bcrypt и обновить.

### Что насчёт колонки `migrated`?

* Можно иметь поле `password_migrated BOOLEAN`. При lazy-реhash ставить в True.
* Но оно дублирует информацию, которую уже хранит `password_hash` (если в нём содержится формат). Поэтому отдельный флаг чаще не нужен и может привести к рассинхронизации.
* Полезно лишь если:

  * ваш старый формат не хранился с явным префиксом (например, просто md5 hex) и вы хотите быстро фильтровать тех, кого нужно мигрировать — но даже тогда лучше использовать проверку формата.

### Edge cases и детали

* **Атомарность:** при одновременных логинах двух потоков может получиться race при записи нового хэша. Делайте обновление атомарным (UPDATE WHERE password_hash = <old_hash>), либо используйте транзакцию.
* **Логи:** не логгируйте пароли/хэши. Логи должны фиксировать факт миграции, но без чувствительной информации.
* **Сессии:** после пересчёта пароля стоит ли инвалидировать другие сессии? Решение по безопасности: не обязательно, но можно.
* **Тесты:** проверьте случай: пользователь с md5-строкой логинится → verify True → password_hash обновился на bcrypt. Также протестируйте неверный пароль, и параллельные логины.
* **Массовая принудительная миграция:** если хотите ускорить процесс (например, отключить deprecated алгоритмы), можно отправлять пользователям письма с требованием сменить пароль либо назначать принудительный сброс при следующем входе.

### Полезные тестовые сценарии (unit/integration)

1. Пользователь со старым хэшем успешно логинится; после логина в БД — новый хэш.
2. Попытка логина со старым хэшем и неверным паролем — не проходит; хэш не меняется.
3. Проверка needs_update правильно детектирует старые форматы.
4. Конкурентные логины не ломают целостность (тест на race, atomic UPDATE).

---

## Итог — рекомендации (шаги внедрения)

1. **Внедрить CryptContext / единый механизм хеширования** (или эквивалент в выбранном языке). Настроить preferred scheme (argon2/bcrypt).
2. **Не добавлять лишний migrated-флаг**, если ваш хэш уже содержит информацию о схеме; используйте `needs_update`/детекцию формата.
3. Реализовать **lazy rehash** при логине; для безопасности — атомарно обновлять запись.
4. **Поддержать проверку нескольких pepper’ов** (если используется pepper) до завершения ротации.
5. Подготовить **план на случай утечки pepper**: принудительная смена паролей/инвалидация и т. п.
6. Написать тесты, покрывающие миграцию и граничные случаи.
7. Документировать политику хеширования в репозитории (какие схемы, cost-факторы).

---

## 1. Что такое HMAC — и зачем он нужен

### 📖 Определение

**HMAC (Hash-based Message Authentication Code)** — это способ вычислить *криптографическую подпись* для сообщения, чтобы:

* убедиться, что оно **не было изменено** (целостность);
* убедиться, что оно **пришло от доверенной стороны**, владеющей секретом (аутентификация).

> Формально:
> **HMAC = hash( (key ⊕ opad) ∥ hash( (key ⊕ ipad) ∥ message ))**

(где `⊕` — XOR, `∥` — конкатенация, `opad` и `ipad` — фиксированные маски, чтобы не было коллизий между слоями)

---

### 🧠 Идея простыми словами

Обычный хэш (`sha256(message)`) защищает только от случайных изменений — любой, кто видит сообщение, может пересчитать хэш.
HMAC добавляет **секретный ключ**, известный только доверенным участникам.

→ Если кто-то подделает сообщение, он не сможет сгенерировать правильную HMAC-подпись без секрета.

---

### 📦 Пример (Python)

```python
import hmac, hashlib

message = b"user_id=42&role=admin"
secret_key = b"supersecret"

signature = hmac.new(secret_key, message, hashlib.sha256).hexdigest()
print(signature)
```

💡 Теперь сервер может проверить подпись:

```python
def verify_hmac(message, signature, secret_key):
    expected = hmac.new(secret_key, message, hashlib.sha256).hexdigest()
    return hmac.compare_digest(expected, signature)
```

> `compare_digest` защищает от **тайминговых атак** — он сравнивает строки константным временем.

---

### ⚙️ Где используется HMAC

1. **JWT с алгоритмом HS256** — это HMAC-SHA256.
2. **Подпись API-запросов** (например, AWS S3, Stripe, Telegram Bot API).
3. **Коды двухфакторной аутентификации (TOTP/HOTP)** — основаны на HMAC.
4. **В pepper-сценариях** — для добавления секретного уровня при хэшировании пароля (HMAC(pepper, password)).

---

### 🚫 Не путать

* HMAC ≠ шифрование → оно не скрывает сообщение, только подтверждает, что оно не изменено.
* HMAC ≠ цифровая подпись (RSA/ECDSA) → она симметричная: обе стороны знают один и тот же секрет.

---

## 2. Что будет, если потерять pepper?

### 🧨 Потеря pepper = потеря возможности проверить пароли

Если вы используете pepper как часть входа при хэшировании (`hash(salt + password + pepper)`),
а потом **pepper удалён или повреждён**, вы больше **не сможете верифицировать** ни один пароль.
С точки зрения сервера, все пользователи имеют “неправильный пароль”.

---

### 📉 Масштаб последствий

| Сценарий                             | Что произойдёт                                       | Как восстанавливаться                                                      |
| ------------------------------------ | ---------------------------------------------------- | -------------------------------------------------------------------------- |
| 🔹 Pepper случайно удалён            | Все хэши становятся бесполезными                     | Принудительный сброс паролей                                               |
| 🔹 Pepper заменён новым без миграции | Старые пользователи не смогут войти                  | Lazy-rehash при логине не сработает (потому что старый pepper не известен) |
| 🔹 Pepper утёк                       | Злоумышленник сможет проводить offline-атаки на базу | Требуется срочная ротация pepper и/или сброс паролей                       |

---

### 🧮 Насколько риск велик

Риск утечки или потери pepper не теоретический — вот типичные случаи:

1. **Pepper хранится в `.env` и попадает в git** → частая ошибка разработчиков.
2. **Pepper в конфигурационном файле**, который деплоится в Docker-образ → любой с доступом к образу получает ключ.
3. **Pepper в переменной окружения**, но логи или мониторинг выводят env-переменные (часто в CI/CD).
4. **Pepper заменён при обновлении** без процедуры ротации → массовый lock-out пользователей.
5. **Смена инфраструктуры / DevOps-инциденты** → потеря старых env-секретов.

---

### 📌 Практические меры

* Хранить pepper **в Secret Manager или KMS** (а не в .env).
* Делать **бэкап** pepper (зашифрованный и отдельно от кода).
* Реализовать **двухуровневую поддержку**:

  ```python
  PEPPERS = [PEPPER_CURRENT, PEPPER_PREVIOUS]
  for p in PEPPERS:
      if verify_with_pepper(p, password):
          if p is not PEPPER_CURRENT:
              rehash_with_current_pepper()
          return True
  ```
* В случае утечки — **сменить pepper и перехешировать пароли** при следующем логине (lazy rotation).

---

### 💬 Итог

Pepper — мощный, но «острый» инструмент:
он **защищает от утечки базы**, но создаёт **риск потери работоспособности**, если сам потерян.

Поэтому:

* Для критичных систем — лучше KMS/Secrets Manager.
* Для небольших — хотя бы надёжный `.env` + офлайн-бэкап и ротация под контролем.

---

## 3. Менеджеры секретов и компромиссы для малого бизнеса

### ☁️ Почему вообще нужны секрет-менеджеры

Secret Manager — это “взрослый” способ:

* централизованно хранить ключи/пароли/токены;
* управлять доступом и аудитом;
* вращать ключи без ручного вмешательства;
* избегать “секретов в коде”.

### 💸 Но да, у них есть цена

AWS Secrets Manager, Google Secret Manager, HashiCorp Vault Enterprise и др. — стоят денег,
и иногда дороже, чем сам VPS маленького проекта.

---

### 💡 Альтернативы и компромиссы

#### 1. **Бесплатные/самостоятельно размещённые решения**

| Решение                           | Особенности                                                              |
| --------------------------------- | ------------------------------------------------------------------------ |
| **HashiCorp Vault (open source)** | Надёжный, но требует DevOps-опыта. Самое популярное self-hosted решение. |
| **Doppler (free tier)**           | Облачное хранение с UI и API, есть бесплатный план.                      |
| **Infisical (open source)**       | Современный open-source менеджер секретов, легко деплоится в Docker.     |
| **Bitwarden Secrets Manager**     | Бесплатен для небольших команд, если уже используете Bitwarden.          |

→ Для учебных и малых бизнесов **Vault + Docker Compose** или **Infisical** — золотая середина: бесплатно и безопасно.

---

#### 2. **Компромиссный вариант без менеджера**

Используйте **.env файлы** + **шифрование и контроль доступа**:

* Секреты хранятся в `.env.enc` (зашифрованном файле).
* Дешифровка при деплое с помощью симметричного ключа (например, AES или GPG).
* Ключ шифрования — хранится офлайн или в CI/CD как переменная.

Инструменты:

* [Doppler CLI](https://www.doppler.com/) — даже без платной подписки;
* [sops](https://github.com/mozilla/sops) — отличная утилита от Mozilla для шифрования YAML/ENV файлов.

---

#### 3. **Минимум, который должен быть даже у маленького проекта**

* Не хранить секреты в Git.
* Не передавать `.env` коллегам напрямую (только зашифровано).
* Держать один резервный офлайн-бэкап.
* Обновлять секреты хотя бы раз в 6–12 месяцев.
* При деплое — загружать их из CI/CD переменных окружения.

---

### 📊 Резюме по вариантам

| Уровень зрелости | Хранение                 | Безопасность | Стоимость             |
| ---------------- | ------------------------ | ------------ | --------------------- |
| ❌ Плохой         | В коде (settings.py)     | 0            | 0                     |
| ⚠️ Минимум       | `.env` + .gitignore      | базовая      | 0                     |
| ✅ Средний        | `.env.enc` + GPG/SOPS    | хорошая      | 0                     |
| 🔒 Продвинутый   | Vault / Doppler / AWS SM | высокая      | от $0–$0.4/секрет/мес |
| 🧱 Корпоративный | KMS + rotation + audit   | максимальная | зависит от нагрузки   |

---

### 🔧 Рекомендация для малых команд

**Оптимальный компромисс:**

* `.env` → `.gitignore` → `.env.sample` (без секретов)
* Pepper и JWT-ключи шифровать с помощью GPG/SOPS; хранить расшифрованную версию только на прод-сервере
* В CI/CD (GitHub Actions, GitLab CI) использовать **Encrypted Variables**
* Настроить cron для напоминания о **ротации секретов раз в полгода**

---
