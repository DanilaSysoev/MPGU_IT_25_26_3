## Agile 5. Основы ООП на С# (максимальный балл 8, дедлай 07.10.2025 включительно)

# Критерии оценивания (макс. 8 баллов)

1. Дизайн интерфейсов (2 б.): у каждого ≥ 2 свойства и ≥ 1 метод;
   сигнатуры методов предполагают взаимодействие объектов по интерфейсам.
2. Реализация классов (3 б.): три класса, каждый реализует ровно две
   разные роли; логика классов различается и соответствует домену.
3. Взаимодействие объектов (2 б.): вызовы методов с параметрами
   интерфейсных типов; демонстрация кооперации.
4. Демо-программа (1 б.): сценарий, показывающий ключевые взаимодействия.

### Штрафы за «грязный» код (каждый пункт −1 балл)

* Длинные строки (любая строка кода ≥ 80 символов).
* Несоответствие C#-стилю (snake_case в публичном API и т. п.).
* Магические константы вместо const/readonly/настроек.
* Дублирование кода, неочевидные побочные эффекты.
* Неверные модификаторы доступа, игнорирование null-проверок/инвариантов.

---

## Задача 1. «Умный дом»: сенсоры, актуаторы, контроллеры

**Интерфейсы**

* `ISensor`: свойства — «идентификатор», «последнее измерение»;
  метод — «передать отчёт контроллеру».
* `IActuator`: свойства — «идентификатор», «состояние включения»;
  метод — «получить команду от контроллера».
* `IController`: свойства — «название/метка», «уровень загрузки»;
  метод — «переадресовать показания сенсора актуатору».

**Классы**

* `КомбоУстройство` (`ISensor`+`IActuator`)

  * Как `ISensor`: хранит актуальное измерение; отчёт повышает загрузку
    у контроллера; допускается фильтрация шума.
  * Как `IActuator`: переключает состояние по командам; запрещает
    противоречивые команды (инвариант: «одно состояние за раз»).
  * Связка: контроллер может адресовать команды этому же объекту.
* `ХабКонтроллер` (`IActuator`+`IController`)

  * Как `IActuator`: выступает «главным реле»; фиксирует последнее
    принятое действие.
  * Как `IController`: по порогам преобразует измерения в команды для
    целей; учитывает приоритеты/очередь.
  * Инвариант: порядок обработки стабильный при равных условиях.
* `МетеоАгрегатор` (`ISensor`+`IController`)

  * Как `ISensor`: поддерживает «виртуальное» измерение на основе
    агрегации входящих данных.
  * Как `IController`: при получении отчёта от сенсора обновляет
    агрегат и рассылает команды целям.
  * Инвариант: агрегат монотонно меняется по заданному правилу.

**Демо**

* Сценарий: сенсор → контроллер → актуатор; проверка порога и команды.

---

## Задача 2. «E-commerce»: склад, заказ, промо

**Интерфейсы**

* `IInventory`: свойства — «идентификатор товара», «остаток»;
  метод — «передать в заказ указанное количество».
* `IOrder`: свойства — «идентификатор заказа», «итоговая сумма»;
  метод — «применить промо».
* `IPromo`: свойства — «код», «величина скидки/бонуса»;
  метод — «повлиять на заказ с учётом склада».

**Классы**

* `СкладскаяПозиция` (`IInventory`+`IPromo`)

  * Как `IInventory`: уменьшает остаток при передаче в заказ; валидирует
    количество; логирует движение.
  * Как `IPromo`: применяет правило (например, по сумме/объёму).
  * Инвариант: остаток не уходит в отрицательные значения.
* `КорзинаРезерв` (`IOrder`+`IInventory`)

  * Как `IOrder`: аккумулирует позиции; обновляет сумму.
  * Как `IInventory`: хранит «резерв» единиц для последующей отгрузки.
  * Инвариант: сумма соответствует составу позиций и ценам.
* `ДвижокПромо` (`IPromo`+`IOrder`)

  * Как `IPromo`: может каскадировать скидки.
  * Как `IOrder`: отражает влияние чужих промо (для цепочек правил).
  * Инвариант: применяемые скидки не делают сумму отрицательной.

**Демо**

* Сценарий: передача единиц, применение одного и каскадного промо.

---

## Задача 3. «Графическая сцена»: фигуры, рендер, выбор

**Интерфейсы**

* `IShape`: свойства — «название фигуры», «позиция на плоскости»;
  метод — «взаимодействовать при столкновении с выбираемым объектом».
* `IRenderable`: свойства — «слой», «прозрачность»;
  метод — «выполнить рендер в целевой рендер-объект».
* `ISelectable`: свойства — «признак выбора», «тег/категория»;
  метод — «быть выбранным фигурой».

**Классы**

* `Спрайт` (`IShape`+`IRenderable`)

  * Как `IShape`: сообщает о столкновении и инициирует выбор цели.
  * Как `IRenderable`: рендерится с учётом слоя/прозрачности.
  * Инвариант: положение согласовано для рендера и коллизий.
* `UiЭлемент` (`IRenderable`+`ISelectable`)

  * Как `IRenderable`: отрисовка поверх или под спрайтами.
  * Как `ISelectable`: меняет состояние выбора от пришедшей фигуры.
  * Инвариант: выбранность стабильна до следующего события.
* `ЗонаПопадания` (`IShape`+`ISelectable`)

  * Как `IShape`: служит для хит-теста, инициирует выбор.
  * Как `ISelectable`: помечается выбранной, хранит источник выбора.
  * Инвариант: хранит последнюю причину выбора (для отладки).

**Демо**

* Столкновения меняют выбор; порядок рендера учитывает слои.

---

## Задача 4. «Мессенджер»: пользователь, канал, процессор

**Интерфейсы**

* `IUser`: свойства — «имя пользователя», «флаг онлайн»;
  метод — «отправить текст в канал через процессор».
* `IChannel`: свойства — «идентификатор канала», «число подписчиков»;
  метод — «транслировать сообщение от пользователя через процессор».
* `IMessageProcessor`: свойства — «название процессора», «длина очереди»;
  метод — «обработать текст для пользователя и канала».

**Классы**

* `ЛичныйКаналПользователя` (`IUser`+`IChannel`)

  * Как `IUser`: инициализирует отправку; делегирует в канал.
  * Как `IChannel`: транслирует входящее сообщение подписчикам.
  * Инвариант: циклы самотрансляции предотвращаются.
* `ГруппаФильтр` (`IChannel`+`IMessageProcessor`)

  * Как `IChannel`: принимает сообщения; вызывает процессор.
  * Как `IMessageProcessor`: изменяет/метит текст (фильтрация).
  * Инвариант: счётчик очереди отражает количество обработок.
* `БотПомощник` (`IUser`+`IMessageProcessor`)

  * Как `IUser`: публикует служебные сообщения.
  * Как `IMessageProcessor`: форматирует ответы/реакции.
  * Инвариант: обработка идемпотентна для повторов.

**Демо**

* Пользователь и бот общаются в группе; фильтры применяются.

---

## Задача 5. «Игра»: лекарь, дамагер, торговец

**Интерфейсы**

* `IHealer`: свойства — «имя», «сила исцеления»;
  метод — «лечить атакующего союзника».
* `IDamageDealer`: свойства — «имя», «единицы урона»;
  метод — «атаковать торговца».
* `ITrader`: свойства — «имя», «количество золота/валюты»;
  метод — «совершить сделку с лекарем».

**Классы**

* `ЦелительЛавочник` (`IHealer`+`ITrader`)

  * Как `IHealer`: поднимает состояние союзника-атакующего.
  * Как `ITrader`: проводит обмен ресурсами; контролирует баланс.
  * Инвариант: золото не уходит в «минус».
* `ТеневойКупец` (`IDamageDealer`+`ITrader`)

  * Как `IDamageDealer`: наносит урон целям-торговцам.
  * Как `ITrader`: торгует трофеями; влияет на цены.
  * Инвариант: урон не зависит от текущего золота.
* `БоевойМаг` (`IHealer`+`IDamageDealer`)

  * Как `IHealer`: лечит атакующих союзников.
  * Как `IDamageDealer`: атакует цели; учитывает перезарядку.
  * Инвариант: ресурсы навыков ограничены кулдаунами.

**Демо**

* Ход боя, лечение, сделки и влияние ресурсов.

---

## Задача 6. «Банкинг»: счета, платежи, антифрод

**Интерфейсы**

* `IAccount`: свойства — «идентификатор счёта», «текущий баланс»;
  метод — «инициировать перевод через платёж на другой счёт».
* `IPayment`: свойства — «идентификатор платежа», «размер комиссии»;
  метод — «списать и зачислить сумму между счетами».
* `IFraudCheck`: свойства — «название правила», «оценка риска»;
  метод — «оценить платёж от отправителя».

**Классы**

* `СчётИнициатор` (`IAccount`+`IPayment`)

  * Как `IAccount`: проверяет баланс и лимиты.
  * Как `IPayment`: применяет комиссию; фиксирует проводку.
  * Инвариант: баланс не становится отрицательным без овердрафта.
* `ПлатёжСКонтролем` (`IPayment`+`IFraudCheck`)

  * Как `IPayment`: выполняет перевод при допустимом риске.
  * Как `IFraudCheck`: вычисляет риск и меняет решение/комиссию.
  * Инвариант: высокий риск блокирует списание.
* `СчётСКонтролем` (`IAccount`+`IFraudCheck`)

  * Как `IAccount`: отражает входящие/исходящие операции.
  * Как `IFraudCheck`: добавляет правила по истории счёта.
  * Инвариант: одна операция — одна запись аудита.

**Демо**

* Перевод между счетами; антифрод меняет исход.

---

## Задача 7. «Логистика»: посылки, маршруты, тарифы

**Интерфейсы**

* `IPackage`: свойства — «трек-номер», «вес»;
  метод — «передать посылку на маршрут».
* `IRoute`: свойства — «точка отправки», «точка назначения»;
  метод — «отправить посылку с применением тарифа».
* `ITariff`: свойства — «название тарифа», «цена за единицу веса»;
  метод — «рассчитать стоимость для посылки и маршрута».

**Классы**

* `СамомаршрутизируемаяПосылка` (`IPackage`+`IRoute`)

  * Как `IPackage`: знает свои параметры; выбирает маршрут.
  * Как `IRoute`: может «проложить» путь для самой себя.
  * Инвариант: вес неотрицателен, направления валидны.
* `МаршрутСТарифом` (`IRoute`+`ITariff`)

  * Как `IRoute`: доставляет и логирует этапы.
  * Как `ITariff`: даёт динамическую цену (например, по зонам).
  * Инвариант: расчёт стоимости детерминирован для равных входов.
* `ПосылкаСоСкидкой` (`IPackage`+`ITariff`)

  * Как `IPackage`: может требовать особые условия.
  * Как `ITariff`: снижает цену по своим правилам.
  * Инвариант: скидка не делает цену отрицательной.

**Демо**

* Два маршрута с разной стоимостью; выбор на основе тарифа.

---

## Задача 8. «Обучение»: курс, студент, оценивание

**Интерфейсы**

* `ICourse`: свойства — «код курса», «количество кредитов»;
  метод — «зачислить студента».
* `IStudent`: свойства — «имя студента», «уровень/курс обучения»;
  метод — «сдать работу на курс через оценивателя».
* `IGrader`: свойства — «схема оценивания», «число попыток»;
  метод — «оценить работу студента на курсе».

**Классы**

* `КурсСоСвоимОцениванием` (`ICourse`+`IGrader`)

  * Как `ICourse`: ведёт список слушателей.
  * Как `IGrader`: оценивает по своей схеме и попыткам.
  * Инвариант: попытки не превышают лимит.
* `СтудентТьютор` (`IStudent`+`ICourse`)

  * Как `IStudent`: подаёт работы, отслеживает прогресс.
  * Как `ICourse`: ведёт мини-модуль для других.
  * Инвариант: роли не конфликтуют в одном и том же модуле.
* `АссистентСтароста` (`IStudent`+`IGrader`)

  * Как `IStudent`: имеет собственные работы.
  * Как `IGrader`: может оценивать других по правилам курса.
  * Инвариант: не оценивает свои же попытки.

**Демо**

* Зачисление, сдача, повторы с разными весами.

---

## Задача 9. «Медиа»: трек, плейлист, рекомендации

**Интерфейсы**

* `ITrack`: свойства — «идентификатор трека», «длительность»;
  метод — «проигрывать в контексте плейлиста».
* `IPlaylist`: свойства — «название списка», «число элементов»;
  метод — «добавить трек с учётом рекомендации».
* `IRecommender`: свойства — «название модели», «сила влияния»;
  метод — «предложить треки на основе опорного трека».

**Классы**

* `КомпозицияСоздательСписков` (`ITrack`+`IPlaylist`)

  * Как `ITrack`: проигрывание может триггерить добавления.
  * Как `IPlaylist`: формирует новые списки на основе прослушиваний.
  * Инвариант: циклы автодобавлений ограничены.
* `УмныйПлейлист` (`IPlaylist`+`IRecommender`)

  * Как `IPlaylist`: управляет порядком/дубликатами.
  * Как `IRecommender`: предлагает элементы по модели.
  * Инвариант: рекомендации детерминированы при фиксированном зерне.
* `ТрекСемантический` (`ITrack`+`IRecommender`)

  * Как `ITrack`: содержит метаданные сходства.
  * Как `IRecommender`: на их основе предлагает похожие треки.
  * Инвариант: метрика сходства симметрична либо документирована.

**Демо**

* Добавление трека, автодобавления, сравнение плейлистов.

---

## Задача 10. «DevOps»: сборка, артефакт, репозиторий

**Интерфейсы**

* `IBuild`: свойства — «идентификатор сборки», «статус»;
  метод — «опубликовать в виде артефакта в репозиторий».
* `IArtifact`: свойства — «название артефакта», «размер»;
  метод — «продвинуть артефакт в выбранный канал/хранилище».
* `IRepository`: свойства — «адрес хранилища», «число пакетов»;
  метод — «принять артефакт от сборки».

**Классы**

* `СамодостаточнаяСборка` (`IBuild`+`IArtifact`)

  * Как `IBuild`: создаёт публикацию и версионирует релиз.
  * Как `IArtifact`: знает правила продвижения по каналам.
  * Инвариант: статус согласован с этапом публикации.
* `АртефактСКвотами` (`IArtifact`+`IRepository`)

  * Как `IArtifact`: проверяет совместимость/подпись.
  * Как `IRepository`: применяет квоты и политику приёма.
  * Инвариант: приём невозможен при нарушении политики.
* `ПайплайнХранилище` (`IBuild`+`IRepository`)

  * Как `IBuild`: управляет стадиями, логирует результаты.
  * Как `IRepository`: умеет временно кэшировать публикации.
  * Инвариант: одна сборка — один набор артефактов на выпуск.

**Демо**

* Публикация, продвижение в «stable», проверка политики хранилища.

---

### Примечания по стилю (для избежания штрафов)

* Используйте **PascalCase** для типов/свойств/методов, **camelCase** для приватных полей с `_` как префиксом по желанию (`_count`).
* Выносите числа в `const`/`static readonly` (например, `const int MaxRetries = 3;`).
* Держите строки <80 символов, длинные выражения переносите.
* Старайтесь, чтобы публичные методы принимали **интерфейсы**, а не конкретные классы.
* Чётко задавайте модификаторы доступа.
* Избегайте скрытых побочных эффектов — по возможности возвращайте значения и логируйте действия.
