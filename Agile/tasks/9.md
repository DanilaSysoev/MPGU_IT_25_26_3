## Agile 9. Основы ООП на С# (максимальный балл 10 + 2, дедлай 11.11.2025 включительно)

---

## Критерии оценки

| № | Критерий                                                                       | Баллы | Комментарий                                                      |
| - | ------------------------------------------------------------------------------ | :---: | ---------------------------------------------------------------- |
| **1** | **Хранение предметов/объектов через `List` и доступ по позиции**                   |   2   | Корректное использование `List<T>`, сохранение порядка элементов |
| **2** | **Поддержка `Dictionary` для быстрого доступа по `Id` и синхронизация со списком** |   2   | Корректное обновление обеих структур при добавлении и удалении   |
| **3** | **Сокрытие вложенной коллекции через `IReadOnlyList<>`**                           |   2   | Отсутствует возможность модификации вложенного списка извне      |
| **4** | **Индексаторы (`int`, `string`) с корректными исключениями**                       |   2   | Правильная работа и типы исключений при ошибках доступа          |
| **5** | **Генератор с `yield return` для фильтрации элементов**                            |   2   | Ленивое перечисление без промежуточных коллекций                 |
| **6** | **Реализация**                                   | до 2 баллов | Субъективно оценивается реализация дополнительной функциональности, не описанной в условии явно, но согласующейся с контекстом. |

**Итого:** **12 баллов**


---

### Штрафы за «грязный» код (каждый пункт −1 балл)

* Длинные строки (любая строка кода ≥ 80 символов).
* Несоответствие C#-стилю (snake_case в публичном API и т. п.).
* Магические константы вместо const/readonly/настроек.
* Дублирование кода, неочевидные побочные эффекты.
* Неверные модификаторы доступа, игнорирование null-проверок/инвариантов.

---

<details>
<summary><strong style="font-size: 18;">Задача 1</strong></summary>

# Задача: Инвентарь и эффекты предметов

## Контекст

Нужно спроектировать простой инвентарь для одиночной RPG. В инвентаре лежат предметы, у каждого предмета есть набор эффектов (бафы/дебафы). Эффекты нельзя изменять извне — только читать.
Инвентарь предоставляет быстрый доступ к предметам по позиции и по строковому `Id`, умеет лениво перечислять предметы по минимальной редкости и корректно поддерживает добавление и удаление предметов, синхронизируя внутренние структуры данных.

---

## Обязательные требования

1. **Хранение через List**

   * Внутри `Inventory` предметы хранятся в `List<Item>`; порядок элементов соответствует позиции в инвентаре.

2. **Быстрый доступ по Id через Dictionary**

   * В `Inventory` поддерживается `Dictionary<string, Item>` для поиска по `Id`.
   * Словарь всегда синхронизирован со списком при добавлении и удалении предметов.

3. **Сокрытие вложенной коллекции эффектов через IReadOnly***

   * У `Item` есть внутренняя изменяемая коллекция эффектов `List<Effect>`.
   * Снаружи она доступна только как `IReadOnlyList<Effect>` (нельзя получить коллекцию, позволяющую её изменять).

4. **Индексаторы в Inventory**

   * `this[int index]` — доступ к предмету по позиции (из списка).

     * При выходе за границы — `ArgumentOutOfRangeException`.
   * `this[string id]` — доступ к предмету по `Id` (из словаря).

     * При `id == null` — `ArgumentNullException`.
     * При отсутствии ключа — `KeyNotFoundException`.

5. **Генератор с yield return**

   * Метод `IEnumerable<Item> EnumerateByRarity(Rarity minRarity)` лениво перечисляет предметы с редкостью не ниже заданной.
   * Никаких промежуточных коллекций — только `yield return`.

6. **Добавление предметов**

   * Метод `void Add(Item item)` добавляет предмет в конец списка и в словарь.
   * При `null` — `ArgumentNullException`.
   * При конфликте `Id` — `ArgumentException` (дубликаты запрещены).

7. **Удаление предметов с корректной синхронизацией**

   * `bool RemoveAt(int index)` — удаляет предмет по позиции; при успехе удаляет его из словаря по `Id`.
   * `bool RemoveById(string id)` — удаляет предмет по `Id` и из списка.
   * После любого успешного удаления список и словарь полностью синхронизированы.

---

## Описание классов и структуры

### Перечисление `Rarity`

* **Назначение:** описывает редкость предмета.
* **Структура:** значения вроде `Common`, `Uncommon`, `Rare`, `Epic`, `Legendary`.
* **Использование:** фильтрация в методе `EnumerateByRarity` и характеристика качества предмета.

---

### Класс `Effect`

* **Назначение:** атомарный эффект предмета (баф или дебаф).
* **Поля и свойства:**

  * `Code : string` — короткий код эффекта (например `"atk"` или `"hp"`).
  * `Magnitude : int` — сила эффекта (например `+3` к атаке).
* **Поведение:**

  * Эффекты неизменяемы после создания.
  * Код эффекта не может быть пустым или пробельным.
  * Может переопределять `ToString()` для удобства отладки.

---

### Класс `Item`

* **Назначение:** предмет инвентаря с идентификатором, названием, редкостью и набором эффектов.
* **Поля и свойства:**

  * `Id : string` — уникальный идентификатор предмета.
  * `Name : string` — имя предмета.
  * `Rarity : Rarity` — редкость.
  * `Effects : IReadOnlyList<Effect>` — список эффектов (только для чтения).
* **Внутреннее состояние:**

  * Приватное поле `_effects : List<Effect>` — хранилище эффектов.
  * Публичное свойство `Effects` возвращает `_effects` как `IReadOnlyList<Effect>`.
* **Поведение:**

  * Эффекты можно добавлять только внутренними методами, недоступными извне.
  * Наружный код не имеет доступа к изменяемой коллекции эффектов.
  * Конструктор или метод `AddEffect(Effect e)` могут использоваться для инициализации эффектов.

---

### Класс `Inventory`

* **Назначение:** агрегирует предметы и обеспечивает доступ к ним по позиции и `Id`.
* **Поля и свойства:**

  * `_items : List<Item>` — список всех предметов в порядке их добавления.
  * `_byId : Dictionary<string, Item>` — словарь для быстрого доступа по `Id`.
  * `Count : int` — количество предметов в инвентаре.
* **Методы и индексаторы:**

  * `Item this[int index]` — возвращает предмет по позиции; при неверной — исключение.
  * `Item this[string id]` — возвращает предмет по `Id`; при `null` или отсутствии ключа — исключение.
  * `void Add(Item item)` — добавляет предмет; обновляет список и словарь.
  * `bool RemoveAt(int index)` — удаляет предмет по индексу; синхронно удаляет из словаря.
  * `bool RemoveById(string id)` — удаляет предмет по `Id`; синхронно удаляет из списка.
  * `IEnumerable<Item> EnumerateByRarity(Rarity minRarity)` — ленивое перечисление через `yield return`.
  * `IEnumerator<Item> GetEnumerator()` — поддержка `foreach`.
* **Инварианты:**

  * Каждый предмет присутствует и в списке, и в словаре.
  * Идентификаторы уникальны.
  * Добавления и удаления поддерживают согласованность между структурами.

</details>

---

<details>
<summary><strong style="font-size: 18;">Задача 2</strong></summary>
Отлично — вот вторая задача по тому же шаблону, но в другой доменной области.

---

# Задача: Журнал квестов и цели

## Контекст

Нужно спроектировать журнал квестов для одиночной RPG. Каждый квест имеет уникальный строковый `Id`, название, сложность и набор «целей» (подзадач). Цели нельзя изменять извне — только читать. Журнал предоставляет быстрый доступ к квестам по позиции и по `Id`, умеет лениво перечислять квесты по минимальной сложности и корректно поддерживает добавление и удаление квестов, синхронизируя внутренние структуры данных.

---

## Обязательные требования

1. **Хранение через List**

   * Внутри `QuestLog` квесты хранятся в `List<Quest>`; порядок элементов соответствует позиции в журнале.

2. **Быстрый доступ по Id через Dictionary**

   * В `QuestLog` поддерживается `Dictionary<string, Quest>` для поиска по `Id`.
   * Словарь всегда синхронизирован со списком при добавлении и удалении квестов.

3. **Сокрытие вложенной коллекции целей через IReadOnly***

   * У `Quest` есть внутренняя изменяемая коллекция целей `List<Objective>`.
   * Снаружи она доступна только как `IReadOnlyList<Objective>` (нельзя получить коллекцию, позволяющую её изменять).

4. **Индексаторы в QuestLog**

   * `this[int index]` — доступ к квесту по позиции (из списка).

     * При выходе за границы — `ArgumentOutOfRangeException`.
   * `this[string id]` — доступ к квесту по `Id` (из словаря).

     * При `id == null` — `ArgumentNullException`.
     * При отсутствии ключа — `KeyNotFoundException`.

5. **Генератор с yield return**

   * Метод `IEnumerable<Quest> EnumerateByDifficulty(Difficulty minDifficulty)` лениво перечисляет квесты со сложностью не ниже заданной.
   * Никаких промежуточных коллекций — только `yield return`.

6. **Добавление квестов**

   * Метод `void Add(Quest quest)` добавляет квест в конец списка и в словарь.
   * При `null` — `ArgumentNullException`.
   * При конфликте `Id` — `ArgumentException` (дубликаты запрещены).

7. **Удаление квестов с корректной синхронизацией**

   * `bool RemoveAt(int index)` — удаляет квест по позиции; при успехе удаляет его из словаря по `Id`.
   * `bool RemoveById(string id)` — удаляет квест по `Id` и из списка.
   * После любого успешного удаления список и словарь полностью синхронизированы.

---

## Описание классов и структуры

### Перечисление `Difficulty`

* **Назначение:** описывает сложность квеста.
* **Структура:** значения, например `Trivial`, `Easy`, `Normal`, `Hard`, `Nightmare` с возрастающим порядком.
* **Использование:** фильтрация в методе `EnumerateByDifficulty` и общая характеристика квеста.

---

### Класс `Objective`

* **Назначение:** атомарная цель квеста (подзадача).
* **Поля и свойства:**

  * `Code : string` — короткий код цели (например `"kill_wolves"`, `"gather_herbs"`).
  * `Description : string` — человекочитаемое описание.
  * `RequiredCount : int` — требуемое количество (может быть `1` для булевых целей).
* **Поведение:**

  * Экземпляры неизменяемы после создания.
  * `Code` не может быть пустым или пробельным, `RequiredCount >= 1`.
  * Допускается переопределить `ToString()` для отладки.

---

### Класс `Quest`

* **Назначение:** квест с идентификатором, названием, сложностью и набором целей.
* **Поля и свойства:**

  * `Id : string` — уникальный идентификатор квеста.
  * `Title : string` — название квеста.
  * `Difficulty : Difficulty` — сложность.
  * `Objectives : IReadOnlyList<Objective>` — цели квеста (только чтение).
* **Внутреннее состояние:**

  * Приватное поле `_objectives : List<Objective>` — хранилище целей.
  * Публичное свойство `Objectives` возвращает `_objectives` как `IReadOnlyList<Objective>`.
* **Поведение:**

  * Цели можно добавлять только внутренними методами/конструктором; извне — только чтение.
  * Конструктор или `AddObjective(Objective o)` могут использоваться для инициализации целей.
* **Инварианты:**

  * `Id` и `Title` — не пустые/не пробельные.

---

### Класс `QuestLog`

* **Назначение:** агрегирует квесты и обеспечивает доступ к ним по позиции и `Id`.
* **Поля и свойства:**

  * `_quests : List<Quest>` — список квестов в порядке добавления.
  * `_byId : Dictionary<string, Quest>` — словарь для быстрого доступа по `Id`.
  * `Count : int` — количество квестов в журнале.
* **Методы и индексаторы:**

  * `Quest this[int index]` — возвращает квест по позиции; при неверной — исключение.
  * `Quest this[string id]` — возвращает квест по `Id`; при `null` или отсутствии ключа — исключение.
  * `void Add(Quest quest)` — добавляет квест; обновляет список и словарь; запрещает дубликаты `Id`.
  * `bool RemoveAt(int index)` — удаляет квест по индексу; синхронно удаляет из словаря по `Id`.
  * `bool RemoveById(string id)` — удаляет квест по `Id`; синхронно удаляет из списка.
  * `IEnumerable<Quest> EnumerateByDifficulty(Difficulty minDifficulty)` — ленивое перечисление через `yield return`.
  * `IEnumerator<Quest> GetEnumerator()` — поддержка `foreach`.
* **Инварианты:**

  * Каждый квест присутствует и в списке, и в словаре.
  * `Id` уникальны.
  * Любые изменения поддерживают согласованность между структурами.

</details>

---

<details>
<summary><strong style="font-size: 18;">Задача 3</strong></summary>

# Задача: Книга рецептов и ингредиенты

## Контекст

Нужно спроектировать «книгу рецептов» для системы крафта. Каждый рецепт имеет уникальный строковый `Id`, название, уровень сложности (тир) и набор ингредиентов. Список ингредиентов нельзя изменять извне — только читать. Книга рецептов предоставляет быстрый доступ к рецептам по позиции и по `Id`, умеет лениво перечислять рецепты по минимальному уровню тира и корректно обрабатывает добавление и удаление, синхронизируя внутренние структуры данных.

---

## Обязательные требования

1. **Хранение через List**

   * Внутри `RecipeBook` рецепты хранятся в `List<Recipe>`; порядок элементов соответствует позиции в книге.

2. **Быстрый доступ по Id через Dictionary**

   * В `RecipeBook` поддерживается `Dictionary<string, Recipe>` для поиска по `Id`.
   * Словарь всегда синхронизирован со списком при добавлении и удалении рецептов.

3. **Сокрытие вложенной коллекции через IReadOnly***

   * У `Recipe` есть внутренняя изменяемая коллекция ингредиентов `List<Ingredient>`.
   * Снаружи она доступна только как `IReadOnlyList<Ingredient>` (нельзя получить коллекцию, позволяющую её изменять).

4. **Индексаторы в RecipeBook**

   * `this[int index]` — доступ к рецепту по позиции (из списка).

     * При выходе за границы — `ArgumentOutOfRangeException`.
   * `this[string id]` — доступ к рецепту по `Id` (из словаря).

     * При `id == null` — `ArgumentNullException`.
     * При отсутствии ключа — `KeyNotFoundException`.

5. **Генератор с yield return**

   * Метод `IEnumerable<Recipe> EnumerateByTier(CraftTier minTier)` лениво перечисляет рецепты с тиром не ниже заданного.
   * Никаких промежуточных коллекций — только `yield return`.

6. **Добавление рецептов**

   * Метод `void Add(Recipe recipe)` добавляет рецепт в конец списка и в словарь.
   * При `null` — `ArgumentNullException`.
   * При конфликте `Id` — `ArgumentException` (дубликаты запрещены).

7. **Удаление рецептов с корректной синхронизацией**

   * `bool RemoveAt(int index)` — удаляет рецепт по позиции; при успехе удаляет его из словаря по `Id`.
   * `bool RemoveById(string id)` — удаляет рецепт по `Id` и из списка.
   * После любого успешного удаления список и словарь полностью синхронизированы.

---

## Описание классов и структуры

### Перечисление `CraftTier`

* **Назначение:** описывает «тир» (уровень сложности/продвинутости) рецепта.
* **Структура:** значения, например `Basic`, `Advanced`, `Expert`, `Master`, `Mythic` с возрастающим порядком.
* **Использование:** фильтрация в методе `EnumerateByTier` и общая характеристика сложности рецепта.

---

### Класс `Ingredient`

* **Назначение:** атомарный ингредиент рецепта.
* **Поля и свойства:**

  * `Code : string` — короткий код ингредиента (например `"iron_ore"`, `"oak_wood"`).
  * `Quantity : int` — требуемое количество (строго `>= 1`).
* **Поведение:**

  * Экземпляры неизменяемы после создания.
  * `Code` не может быть пустым или пробельным; `Quantity >= 1`.
  * При желании можно переопределить `ToString()` для удобной отладки.

---

### Класс `Recipe`

* **Назначение:** рецепт крафта с идентификатором, названием, тиром и набором ингредиентов.
* **Поля и свойства:**

  * `Id : string` — уникальный идентификатор рецепта.
  * `Title : string` — название рецепта.
  * `Tier : CraftTier` — тир рецепта.
  * `Ingredients : IReadOnlyList<Ingredient>` — список ингредиентов (только чтение).
* **Внутреннее состояние:**

  * Приватное поле `_ingredients : List<Ingredient>` — хранилище ингредиентов.
  * Публичное свойство `Ingredients` возвращает `_ingredients` как `IReadOnlyList<Ingredient>`.
* **Поведение:**

  * Ингредиенты можно добавлять только внутренними методами/конструктором; извне — только чтение.
  * Конструктор или метод `AddIngredient(Ingredient i)` могут использоваться для инициализации состава.
* **Инварианты:**

  * `Id` и `Title` — не пустые/не пробельные.

---

### Класс `RecipeBook`

* **Назначение:** агрегирует рецепты и обеспечивает доступ к ним по позиции и `Id`.
* **Поля и свойства:**

  * `_recipes : List<Recipe>` — список рецептов в порядке добавления.
  * `_byId : Dictionary<string, Recipe>` — словарь для быстрого доступа по `Id`.
  * `Count : int` — количество рецептов в книге.
* **Методы и индексаторы:**

  * `Recipe this[int index]` — возвращает рецепт по позиции; при неверной — исключение.
  * `Recipe this[string id]` — возвращает рецепт по `Id`; при `null` или отсутствии ключа — исключение.
  * `void Add(Recipe recipe)` — добавляет рецепт; обновляет список и словарь; запрещает дубликаты `Id`.
  * `bool RemoveAt(int index)` — удаляет рецепт по индексу; синхронно удаляет из словаря по `Id`.
  * `bool RemoveById(string id)` — удаляет рецепт по `Id`; синхронно удаляет из списка.
  * `IEnumerable<Recipe> EnumerateByTier(CraftTier minTier)` — ленивое перечисление через `yield return`.
  * `IEnumerator<Recipe> GetEnumerator()` — поддержка `foreach`.
* **Инварианты:**

  * Каждый рецепт присутствует и в списке, и в словаре.
  * `Id` уникальны.
  * Любые изменения поддерживают согласованность между структурами.

</details>

---

<details>
<summary><strong style="font-size: 18;">Задача 4</strong></summary>

# Задача: Бестиарий и способности монстров

## Контекст

Нужно спроектировать «бестиарий» для одиночной RPG. Каждый монстр имеет уникальный строковый `Id`, название, уровень опасности и набор способностей. Список способностей нельзя изменять извне — только читать. Бестиарий предоставляет быстрый доступ к монстрам по позиции и по `Id`, умеет лениво перечислять монстров по минимальному уровню опасности и корректно обрабатывает добавление и удаление, синхронизируя внутренние структуры данных.

---

## Обязательные требования

1. **Хранение через List**

   * Внутри `Bestiary` монстры хранятся в `List<Monster>`; порядок элементов соответствует позиции в реестре.

2. **Быстрый доступ по Id через Dictionary**

   * В `Bestiary` поддерживается `Dictionary<string, Monster>` для поиска по `Id`.
   * Словарь всегда синхронизирован со списком при добавлении и удалении монстров.

3. **Сокрытие вложенной коллекции через IReadOnly***

   * У `Monster` есть внутренняя изменяемая коллекция способностей `List<Ability>`.
   * Снаружи она доступна только как `IReadOnlyList<Ability>` (нельзя получить коллекцию, позволяющую её изменять).

4. **Индексаторы в Bestiary**

   * `this[int index]` — доступ к монстру по позиции (из списка).

     * При выходе за границы — `ArgumentOutOfRangeException`.
   * `this[string id]` — доступ к монстру по `Id` (из словаря).

     * При `id == null` — `ArgumentNullException`.
     * При отсутствии ключа — `KeyNotFoundException`.

5. **Генератор с yield return**

   * Метод `IEnumerable<Monster> EnumerateByThreat(ThreatLevel minThreat)` лениво перечисляет монстров с уровнем опасности не ниже заданного.
   * Никаких промежуточных коллекций — только `yield return`.

6. **Добавление монстров**

   * Метод `void Add(Monster monster)` добавляет монстра в конец списка и в словарь.
   * При `null` — `ArgumentNullException`.
   * При конфликте `Id` — `ArgumentException` (дубликаты запрещены).

7. **Удаление монстров с корректной синхронизацией**

   * `bool RemoveAt(int index)` — удаляет монстра по позиции; при успехе удаляет его из словаря по `Id`.
   * `bool RemoveById(string id)` — удаляет монстра по `Id` и из списка.
   * После любого успешного удаления список и словарь полностью синхронизированы.

---

## Описание классов и структуры

### Перечисление `ThreatLevel`

* **Назначение:** описывает уровень опасности монстра.
* **Структура:** значения, например `Minor`, `Moderate`, `Severe`, `Deadly`, `Mythic` с возрастающим порядком.
* **Использование:** фильтрация в методе `EnumerateByThreat` и общая характеристика угрозы.

---

### Класс `Ability`

* **Назначение:** атомарная способность монстра.
* **Поля и свойства:**

  * `Code : string` — короткий код способности (например `"bite"`, `"poison_spit"`, `"stomp"`).
  * `Power : int` — мощность способности (целое число, может быть отрицательным для ослабляющих аур).
  * (опционально) `CooldownSeconds : int` — перезарядка в секундах, если уместно для вашей модели.
* **Поведение:**

  * Экземпляры неизменяемы после создания.
  * `Code` не может быть пустым или пробельным; при наличии `CooldownSeconds` он неотрицателен.
  * Может переопределять `ToString()` для удобной отладки.

---

### Класс `Monster`

* **Назначение:** монстр с идентификатором, названием, уровнем опасности и набором способностей.
* **Поля и свойства:**

  * `Id : string` — уникальный идентификатор монстра.
  * `Name : string` — название.
  * `Threat : ThreatLevel` — уровень опасности.
  * `Abilities : IReadOnlyList<Ability>` — список способностей (только чтение).
* **Внутреннее состояние:**

  * Приватное поле `_abilities : List<Ability>` — хранилище способностей.
  * Публичное свойство `Abilities` возвращает `_abilities` как `IReadOnlyList<Ability>`.
* **Поведение:**

  * Способности можно добавлять только внутренними методами/конструктором; извне — только чтение.
  * Конструктор или метод `AddAbility(Ability a)` могут использоваться для инициализации.

---

### Класс `Bestiary`

* **Назначение:** агрегирует монстров и обеспечивает доступ к ним по позиции и `Id`.
* **Поля и свойства:**

  * `_monsters : List<Monster>` — список монстров в порядке добавления.
  * `_byId : Dictionary<string, Monster>` — словарь для быстрого доступа по `Id`.
  * `Count : int` — количество монстров в бестиарии.
* **Методы и индексаторы:**

  * `Monster this[int index]` — возвращает монстра по позиции; при неверной — исключение.
  * `Monster this[string id]` — возвращает монстра по `Id`; при `null` или отсутствии ключа — исключение.
  * `void Add(Monster monster)` — добавляет монстра; обновляет список и словарь; запрещает дубликаты `Id`.
  * `bool RemoveAt(int index)` — удаляет по индексу; синхронно удаляет из словаря по `Id`.
  * `bool RemoveById(string id)` — удаляет по `Id`; синхронно удаляет из списка.
  * `IEnumerable<Monster> EnumerateByThreat(ThreatLevel minThreat)` — ленивое перечисление через `yield return`.
  * `IEnumerator<Monster> GetEnumerator()` — поддержка `foreach`.
* **Инварианты:**

  * Каждый монстр присутствует и в списке, и в словаре.
  * `Id` уникальны.
  * Любые изменения поддерживают согласованность между структурами.


</details>

---

<details>
<summary><strong style="font-size: 18;">Задача 5</strong></summary>

# Задача: Атлас локаций и точки интереса (POI)

## Контекст

Нужно спроектировать «атлас» игрового мира. Каждая локация имеет уникальный строковый `Id`, название, «ранг» региона и набор точек интереса (POI). Список POI нельзя изменять извне — только читать. Атлас предоставляет быстрый доступ к локациям по позиции и по `Id`, умеет лениво перечислять локации по минимальному рангу и корректно обрабатывает добавление и удаление, синхронизируя внутренние структуры данных.

---

## Обязательные требования

1. **Хранение через List**

   * Внутри `Atlas` локации хранятся в `List<Location>`; порядок соответствует позиции в атласе.

2. **Быстрый доступ по Id через Dictionary**

   * В `Atlas` поддерживается `Dictionary<string, Location>` для поиска по `Id`.
   * Словарь всегда синхронизирован со списком при добавлении и удалении локаций.

3. **Сокрытие вложенной коллекции через IReadOnly***

   * У `Location` есть внутренняя изменяемая коллекция `List<PointOfInterest>`.
   * Снаружи она доступна только как `IReadOnlyList<PointOfInterest>` (без возможности модификации).

4. **Индексаторы в Atlas**

   * `this[int index]` — доступ к локации по позиции (из списка).

     * При выходе за границы — `ArgumentOutOfRangeException`.
   * `this[string id]` — доступ к локации по `Id` (из словаря).

     * При `id == null` — `ArgumentNullException`.
     * При отсутствии ключа — `KeyNotFoundException`.

5. **Генератор с yield return**

   * Метод `IEnumerable<Location> EnumerateByRank(RegionRank minRank)` лениво перечисляет локации с рангом не ниже заданного.
   * Никаких промежуточных коллекций — только `yield return`.

6. **Добавление локаций**

   * `void Add(Location location)` добавляет локацию в конец списка и в словарь.
   * При `null` — `ArgumentNullException`.
   * При конфликте `Id` — `ArgumentException` (дубликаты запрещены).

7. **Удаление локаций с корректной синхронизацией**

   * `bool RemoveAt(int index)` — удаляет локацию по позиции; при успехе удаляет её из словаря по `Id`.
   * `bool RemoveById(string id)` — удаляет локацию по `Id` и из списка.
   * После любого успешного удаления список и словарь полностью синхронизированы.

---

## Описание классов и структуры

### Перечисление `RegionRank`

* **Назначение:** описывает «ранг»/значимость региона.
* **Структура:** значения, например `Local`, `Regional`, `Capital`, `Sacred`, `Mythic` в порядке возрастания.
* **Использование:** фильтрация в `EnumerateByRank` и характеристика масштаба локации.

---

### Класс `PointOfInterest`

* **Назначение:** точка интереса внутри локации (ориентир, данж, памятник).
* **Поля и свойства:**

  * `Code : string` — короткий код POI (например `"ancient_ruins"`, `"market_square"`).
  * `Label : string` — название/подпись для UI.
  * `Importance : int` — важность POI (целое число, `>= 1`).
* **Поведение:**

  * Экземпляры неизменяемы после создания.
  * `Code` не пустой/не пробельный; `Importance >= 1`.
  * При желании можно переопределить `ToString()` для отладки.

---

### Класс `Location`

* **Назначение:** локация с идентификатором, названием, рангом и набором POI.
* **Поля и свойства:**

  * `Id : string` — уникальный идентификатор локации.
  * `Name : string` — название локации.
  * `Rank : RegionRank` — ранг региона.
  * `PointsOfInterest : IReadOnlyList<PointOfInterest>` — список POI (только чтение).
* **Внутреннее состояние:**

  * Приватное поле `_pois : List<PointOfInterest>` — хранилище POI.
  * Публичное свойство `PointsOfInterest` возвращает `_pois` как `IReadOnlyList<PointOfInterest>`.
* **Поведение:**

  * Наполнение POI возможно только внутренними методами/конструктором; извне — только чтение.
  * Допустим метод `AddPoi(PointOfInterest p)` для инициализации при создании.
* **Инварианты:**

  * `Id` и `Name` — не пустые/не пробельные.

---

### Класс `Atlas`

* **Назначение:** агрегирует локации и обеспечивает доступ к ним по позиции и `Id`.
* **Поля и свойства:**

  * `_locations : List<Location>` — список локаций в порядке добавления.
  * `_byId : Dictionary<string, Location>` — словарь для быстрого доступа по `Id`.
  * `Count : int` — количество локаций в атласе.
* **Методы и индексаторы:**

  * `Location this[int index]` — возвращает локацию по позиции; при неверной — исключение.
  * `Location this[string id]` — возвращает локацию по `Id`; при `null` или отсутствии ключа — исключение.
  * `void Add(Location location)` — добавляет локацию; обновляет список и словарь; запрещает дубликаты `Id`.
  * `bool RemoveAt(int index)` — удаляет по индексу; синхронно удаляет из словаря по `Id`.
  * `bool RemoveById(string id)` — удаляет по `Id`; синхронно удаляет из списка.
  * `IEnumerable<Location> EnumerateByRank(RegionRank minRank)` — ленивое перечисление через `yield return`.
  * `IEnumerator<Location> GetEnumerator()` — поддержка `foreach`.
* **Инварианты:**

  * Каждая локация присутствует и в списке, и в словаре.
  * `Id` уникальны.
  * Любые изменения поддерживают согласованность между структурами.

</details>

---