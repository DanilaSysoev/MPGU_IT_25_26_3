## Agile 8. Основы ООП на С# (максимальный балл 8 + 2, дедлай 04.11.2025 включительно)

---

## Критерии оценки

| №     | Критерий                                  | Содержание                                                                                                                                                                           | Баллы   |
| ----- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------- |
| **1** | Объявление собственного делегата          | Делегат объявлен корректно, использует конкретный тип источника, сигнатура соответствует условию                                       | **1.0** |
| **2** | Реализация обычного события               | Первое событие объявлено на основе собственного делегата, вызывается в нужных местах, корректно передаёт аргументы                                                     | **1.0** |
| **3** | Реализация кастомного события             | Второе событие реализовано через `add` / `remove`, подписчики хранятся во внутренней структуре, выводятся уведомления о подписке/отписке, событие вызывается вручную | **2.0** |
| **4** | Использование обработчиков                | Созданы два разных класса-подписчика, каждый реализует нужные обработчики, выполнена подписка и отписка без ошибок                           | **2.0** |
| **5** | Корректность логики и поведение программы | Программа демонстрирует ожидаемое поведение: события вызываются в правильных моментах, значения выводятся в консоль, статистика корректна                                            | **2.0** |
| **6** | **Реализация**                                   | **до 2 баллов** | Субъективно оценивается реализация дополнительной функциональности, не описанной в условии явно, но согласующейся с контекстом. |

---

### Штрафы за «грязный» код (каждый пункт −1 балл)

* Длинные строки (любая строка кода ≥ 80 символов).
* Несоответствие C#-стилю (snake_case в публичном API и т. п.).
* Магические константы вместо const/readonly/настроек.
* Дублирование кода, неочевидные побочные эффекты.
* Неверные модификаторы доступа, игнорирование null-проверок/инвариантов.

---

<details>
<summary><strong style="font-size: 18;">Задача 1: Сигнализация датчика температуры</strong></summary>

Создайте консольное приложение, моделирующее работу **датчика температуры**, который реагирует на изменения и превышение критического порога.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Программа должна моделировать датчик температуры, который периодически обновляет показания и уведомляет подписчиков:

1. **Обычное событие** `TemperatureChanged` — вызывается при каждом новом измерении.

   * Использует **собственный делегат** `TemperatureEventHandler`, принимающий:

     * экземпляр датчика `TemperatureSensor sender`;
     * текущее значение температуры `int value`.
   * Событие объявляется в виде

     ```csharp
     public event TemperatureEventHandler? TemperatureChanged;
     ```

2. **Кастомное событие** `CriticalLevelReached` — возникает, если температура превышает 100 °C.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата.
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При превышении порога вызываются все зарегистрированные обработчики.

---

### Требования к классам

**1. Класс `TemperatureSensor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void TemperatureEventHandler(TemperatureSensor sender, int value);
  ```
* Содержит два события:

  * `TemperatureChanged` — обычное событие, использующее этот делегат.
  * `CriticalLevelReached` — кастомное событие с тем же делегатом.
* Имеет метод `Start()`, который:

  * генерирует несколько случайных значений (например, 5–10) в диапазоне от 80 до 120;
  * вызывает `TemperatureChanged` при каждом новом значении;
  * вызывает `CriticalLevelReached`, если температура превышает 100.

**2. Класс `ConsoleAlarm`**

* Подписывается на оба события.
* При каждом изменении температуры выводит значение в консоль.
* При превышении 100 °C выводит предупреждение (“внимание, перегрев”).

**3. Класс `StatisticsCollector`**

* Подписывается только на событие `TemperatureChanged`.
* Подсчитывает, сколько раз температура превышала 90 °C.
* После завершения работы (метод `Report()`) выводит в консоль статистику.

---

### Поведение программы

1. Программа создаёт экземпляр `TemperatureSensor`.
2. Создаёт два подписчика: `ConsoleAlarm` и `StatisticsCollector`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает датчик методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsoleAlarm` от события `CriticalLevelReached`).
6. Вызывает у статистического сборщика метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущие значения температуры;
* выдавать предупреждения при превышении 100 °C;
* в конце показывать статистику по числу температур выше 90 °C.

</details>


<details>
<summary><strong style="font-size: 18;">Задача 2: Сигнализация уровня заряда батареи</strong></summary>

Создайте консольное приложение, моделирующее работу **монитора батареи**, который реагирует на изменения уровня заряда и достижение критически низкого порога.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Программа должна моделировать монитор батареи, который периодически обновляет уровень заряда и уведомляет подписчиков:

1. **Обычное событие** `LevelChanged` — вызывается при каждом новом измерении уровня заряда (в процентах).

   * Использует **собственный делегат** `BatteryEventHandler`, принимающий:

     * экземпляр монитора `BatteryMonitor sender`;
     * текущее значение уровня `int level`.
   * Событие объявляется в виде

     ```csharp
     public event BatteryEventHandler? LevelChanged;
     ```

2. **Кастомное событие** `CriticalLowReached` — возникает, если уровень заряда опускается ниже 15%.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата (один комбинированный делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При срабатывании порога вызываются все зарегистрированные обработчики.

---

### Требования к классам

**1. Класс `BatteryMonitor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void BatteryEventHandler(BatteryMonitor sender, int level);
  ```
* Содержит два события:

  * `LevelChanged` — обычное событие, использующее этот делегат.
  * `CriticalLowReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует несколько последовательных значений уровня заряда (например, 8–12 значений) в диапазоне от 100 до 5, имитируя постепенную разрядку с небольшими случайными шагами;
  * вызывает `LevelChanged` при каждом новом значении;
  * вызывает `CriticalLowReached`, если уровень заряда стал ниже 15%.

**2. Класс `ConsoleHud`**

* Подписывается на оба события.
* При каждом изменении уровня выводит строку вида: “Уровень: 67%”.
* При достижении критического уровня выводит предупреждение: “Низкий заряд: 14% — включите энергосбережение”.

**3. Класс `LowLevelStats`**

* Подписывается только на событие `LevelChanged`.
* Подсчитывает, сколько раз уровень оказывался ниже 30%.
* После завершения работы (метод `Report()`) выводит в консоль статистику: например, “Ниже 30% было 4 раза”.

---

### Поведение программы

1. Программа создаёт экземпляр `BatteryMonitor`.
2. Создаёт двух подписчиков: `ConsoleHud` и `LowLevelStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает монитор методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsoleHud` от события `CriticalLowReached`).
6. Вызывает у статистического сборщика метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущий уровень заряда после каждого обновления;
* выдавать предупреждение при достижении уровня ниже 15%;
* в конце показывать статистику по числу уровней ниже 30%.

</details>

<details>
<summary><strong style="font-size: 18;">Задача 3: Контроль уровня освещённости</strong></summary>

Создайте консольное приложение, моделирующее работу **сенсора освещённости**, который реагирует на изменения уровня освещённости (в люксах) и на достижение слишком яркого света.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Приложение периодически обновляет уровень освещённости и уведомляет подписчиков:

1. **Обычное событие** `LightLevelChanged` — вызывается при каждом новом измерении.

   * Использует **собственный делегат** `LightEventHandler`, принимающий:

     * экземпляр сенсора `LightSensor sender`;
     * текущее значение освещённости `int lux`.
   * Событие объявляется в виде:

     ```csharp
     public event LightEventHandler? LightLevelChanged;
     ```

2. **Кастомное событие** `BlindingLightReached` — возникает, если освещённость ≥ 800 люкс.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При срабатывании порога вызываются все зарегистрированные обработчики.

---

### Требования к классам

**1. Класс `LightSensor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void LightEventHandler(LightSensor sender, int lux);
  ```
* Содержит два события:

  * `LightLevelChanged` — обычное событие, использующее этот делегат.
  * `BlindingLightReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует 8–12 последовательных значений освещённости в диапазоне 50–1000 люкс (произвольно);
  * вызывает `LightLevelChanged` при каждом новом значении;
  * вызывает `BlindingLightReached`, если значение ≥ 800.

**2. Класс `ConsoleDisplay`**

* Подписывается на оба события.
* При каждом изменении выводит строку вида: “Освещённость: 420 лк”.
* При достижении порога яркости выводит предупреждение: “Слишком ярко: 820 лк — прищурьтесь или снизьте яркость”.

**3. Класс `ComfortAdvisor`**

* Подписывается только на `LightLevelChanged`.
* Подсчитывает, сколько раз освещённость была ниже 200 лк (условно “темновато”).
* Имеет метод `Report()`, который после работы сенсора выводит в консоль статистику: например, “Низкая освещённость (<200 лк) встречалась 3 раза”.

---

### Поведение программы

1. Программа создаёт экземпляр `LightSensor`.
2. Создаёт двух подписчиков: `ConsoleDisplay` и `ComfortAdvisor`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает сенсор методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsoleDisplay` от события `BlindingLightReached`).
6. Вызывает у `ComfortAdvisor` метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущую освещённость после каждого обновления;
* выдавать предупреждение при достижении яркости ≥ 800 лк;
* в конце показывать статистику по числу значений ниже 200 лк.

</details>

<details>
<summary><strong style="font-size: 18;">Задача 4: Монитор загрузки процессора</strong></summary>

Создайте консольное приложение, моделирующее работу **монитора CPU**, который реагирует на изменения загрузки (в процентах) и на достижение критического порога.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Программа должна моделировать мониторинг загрузки процессора, периодически обновляя значение и уведомляя подписчиков:

1. **Обычное событие** `LoadChanged` — вызывается при каждом новом измерении загрузки CPU.

   * Использует **собственный делегат** `CpuEventHandler`, принимающий:

     * экземпляр монитора `CpuMonitor sender`;
     * текущее значение загрузки `int percent`.
   * Событие объявляется в виде:

     ```csharp
     public event CpuEventHandler? LoadChanged;
     ```

2. **Кастомное событие** `OverloadReached` — возникает, если загрузка ≥ 85%.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При срабатывании порога вызываются все зарегистрированные обработчики.

---

### Требования к классам

**1. Класс `CpuMonitor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void CpuEventHandler(CpuMonitor sender, int percent);
  ```
* Содержит два события:

  * `LoadChanged` — обычное событие, использующее этот делегат.
  * `OverloadReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует 10–14 последовательных значений загрузки от 15% до 100% (произвольно, с колебаниями вверх/вниз);
  * вызывает `LoadChanged` при каждом новом значении;
  * вызывает `OverloadReached`, если значение ≥ 85%.

**2. Класс `ConsoleDashboard`**

* Подписывается на оба события.
* При каждом изменении выводит строку вида: “CPU: 62%”.
* При перегрузке выводит предупреждение: “Перегрузка CPU: 91% — сократите нагрузку”.

**3. Класс `OverloadStats`**

* Подписывается только на `LoadChanged`.
* Подсчитывает, сколько раз загрузка была ≥ 70%.
* После завершения работы (метод `Report()`) выводит в консоль статистику, например: “Загрузка ≥ 70% встречалась 5 раз”.

---

### Поведение программы

1. Программа создаёт экземпляр `CpuMonitor`.
2. Создаёт двух подписчиков: `ConsoleDashboard` и `OverloadStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает монитор методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsoleDashboard` от события `OverloadReached`).
6. Вызывает у статистического сборщика метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущую загрузку CPU после каждого обновления;
* выдавать предупреждение при достижении уровня ≥ 85%;
* в конце показывать статистику по числу значений ≥ 70%.


</details>

<details>
<summary><strong style="font-size: 18;">Задача 5: Контроль влажности воздуха</strong></summary>

Создайте консольное приложение, моделирующее работу **гигрометра**, который реагирует на изменения влажности (в процентах) и на достижение критически высокой влажности.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Программа должна моделировать гигрометр, который периодически обновляет влажность и уведомляет подписчиков:

1. **Обычное событие** `HumidityChanged` — вызывается при каждом новом измерении влажности.

   * Использует **собственный делегат** `HumidityEventHandler`, принимающий:

     * экземпляр датчика `HumiditySensor sender`;
     * текущее значение влажности `int percent`.
   * Событие объявляется в виде

     ```csharp
     public event HumidityEventHandler? HumidityChanged;
     ```

2. **Кастомное событие** `MoldRiskReached` — возникает, если влажность достигает или превышает 80%.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При превышении порога вызываются все зарегистрированные обработчики.

---

### Требования к классам

**1. Класс `HumiditySensor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void HumidityEventHandler(HumiditySensor sender, int percent);
  ```
* Содержит два события:

  * `HumidityChanged` — обычное событие, использующее этот делегат.
  * `MoldRiskReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует 8–12 последовательных значений влажности в диапазоне 20–95% (произвольно, с колебаниями);
  * вызывает `HumidityChanged` при каждом новом значении;
  * вызывает `MoldRiskReached`, если значение ≥ 80%.

**2. Класс `ConsolePanel`**

* Подписывается на оба события.
* При каждом изменении выводит строку вида: “Влажность: 57%”.
* При риске плесени выводит предупреждение: “Высокая влажность: 82% — проветрите помещение”.

**3. Класс `ComfortStats`**

* Подписывается только на событие `HumidityChanged`.
* Подсчитывает, сколько раз влажность была ниже 30% (слишком сухо).
* После завершения работы (метод `Report()`) выводит в консоль статистику: например, “Слишком сухо (<30%) было 3 раза”.

---

### Поведение программы

1. Программа создаёт экземпляр `HumiditySensor`.
2. Создаёт двух подписчиков: `ConsolePanel` и `ComfortStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает датчик методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsolePanel` от события `MoldRiskReached`).
6. Вызывает у статистического сборщика метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущую влажность после каждого обновления;
* выдавать предупреждение при достижении уровня ≥ 80%;
* в конце показывать статистику по числу значений ниже 30%.

</details>

<details>
<summary><strong style="font-size: 18;">Задача 6: Счётчик очков игрока</strong></summary>

Создайте консольное приложение, моделирующее работу **счётчика очков игрока**, который реагирует на изменение суммарного счёта и достижение «рубежей» (милстоуны).

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Приложение моделирует набор очков игроком серией «подборов» (случайных прибавок к счёту) и уведомляет подписчиков:

1. **Обычное событие** `ScoreChanged` — вызывается при каждом изменении суммарного счёта.

   * Использует **собственный делегат** `ScoreEventHandler`, принимающий:

     * экземпляр счётчика `ScoreMonitor sender`;
     * текущее значение счёта `int score`.
   * Событие объявляется в виде:

     ```csharp
     public event ScoreEventHandler? ScoreChanged;
     ```

2. **Кастомное событие** `MilestoneReached` — возникает при достижении очередной «сотни» очков (100, 200, 300 и т. д.).

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`.
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При срабатывании порога вызываются все зарегистрированные обработчики; в аргумент передаётся достигнутый рубеж (например, 200).

---

### Требования к классам

**1. Класс `ScoreMonitor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void ScoreEventHandler(ScoreMonitor sender, int score);
  ```
* Содержит два события:

  * `ScoreChanged` — обычное событие, использующее этот делегат.
  * `MilestoneReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует 10–14 последовательных «подборов очков» (каждый раз прибавка в диапазоне 5–50);
  * обновляет суммарный счёт и вызывает `ScoreChanged` после каждого подбора;
  * определяет, пересёк ли счёт новую «сотню» (например, было 95, стало 120 — значит достигнут рубеж 100) и вызывает `MilestoneReached` для каждого пересечённого рубежа.

**2. Класс `ConsoleAnnouncer`**

* Подписывается на оба события.
* При каждом изменении счёта выводит строку: “Счёт: 235”.
* При достижении рубежа выводит сообщение: “Достигнут рубеж: 300”.

**3. Класс `ComboStats`**

* Подписывается только на событие `ScoreChanged`.
* Отслеживает «крупные подборы» — считает, сколько раз разовая прибавка была не менее 30 очков.
* После завершения работы (метод `Report()`) выводит в консоль статистику: например, “Крупных подборов (≥30) было 4”.

---

### Поведение программы

1. Программа создаёт экземпляр `ScoreMonitor`.
2. Создаёт двух подписчиков: `ConsoleAnnouncer` и `ComboStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает монитор методом `Start()`.
5. После генерации всех значений отписывает один из обработчиков (например, `ConsoleAnnouncer` от события `MilestoneReached`).
6. Вызывает у `ComboStats` метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущий счёт после каждого обновления;
* сообщать о достижении рубежей 100/200/300/...;
* в конце показывать статистику по числу «крупных подборов» (прибавок ≥30).

</details>

<details>
<summary><strong style="font-size: 18;">Задача 7: Монитор здоровья игрока</strong></summary>

Создайте консольное приложение, моделирующее работу **монитора здоровья игрока**, который реагирует на изменение очков здоровья (HP) и на достижение критически низкого уровня или смерти.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Приложение моделирует серию игровых событий (получение урона и лечение), обновляющих HP, и уведомляет подписчиков:

1. **Обычное событие** `HealthChanged` — вызывается при каждом изменении здоровья.

   * Использует **собственный делегат** `HealthEventHandler`, принимающий:

     * экземпляр монитора `HealthMonitor sender`;
     * текущее значение здоровья `int hp`.
   * Событие объявляется в виде:

     ```csharp
     public event HealthEventHandler? HealthChanged;
     ```

2. **Кастомное событие** `CriticalStateReached` — возникает, если здоровье опускается ниже 20 HP, а также **событие смерти** `DeathOccurred`, если здоровье стало 0.

   * Реализуются вручную через `add` и `remove`.
   * Тип делегата у обоих кастомных событий — `EventHandler<int>` (в аргументах передаётся текущий HP).
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * При срабатывании порогов вызываются все зарегистрированные обработчики соответствующего события.

---

### Требования к классам

**1. Класс `HealthMonitor`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void HealthEventHandler(HealthMonitor sender, int hp);
  ```
* Содержит три события:

  * `HealthChanged` — обычное событие, использующее этот делегат.
  * `CriticalStateReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
  * `DeathOccurred` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * задаёт стартовое здоровье, например 100 HP;
  * генерирует 10–14 игровых шагов: случайно чередует “получение урона” и “лечение” в разумных пределах (например, урон 5–30, лечение 3–20), не позволяя HP уходить ниже 0 и выше 100;
  * после каждого шага вызывает `HealthChanged`;
  * если после изменения HP стало меньше 20 и больше 0 — вызывает `CriticalStateReached`;
  * если HP стало равно 0 — вызывает `DeathOccurred` и прекращает дальнейшие шаги.

**2. Класс `ConsoleHUD`**

* Подписывается на все события.
* При каждом изменении здоровья выводит строку вида: “HP: 73”.
* При критическом состоянии выводит предупреждение: “Критический уровень HP: 17 — используйте зелье!”
* При смерти выводит сообщение: “Игрок пал. HP: 0”.

**3. Класс `SurvivalStats`**

* Подписывается только на событие `HealthChanged`.
* Подсчитывает, сколько раз значение HP попадало в диапазон 1..19 (критическая зона).
* Имеет метод `Report()`, который после завершения работы монитора выводит статистику: например, “Критических состояний (1..19 HP): 4”.

---

### Поведение программы

1. Программа создаёт экземпляр `HealthMonitor`.
2. Создаёт двух подписчиков: `ConsoleHUD` и `SurvivalStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает монитор методом `Start()`.
5. После завершения (по естественному окончанию шагов или по смерти) отписывает один из обработчиков (например, `ConsoleHUD` от события `CriticalStateReached`).
6. Вызывает у `SurvivalStats` метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущее здоровье после каждого изменения;
* выдавать предупреждение при попадании в критическую зону (<20 HP);
* сообщать о смерти при достижении 0 HP и прекращать симуляцию;
* в конце показывать статистику по числу состояний 1..19 HP.

</details>

<details>
<summary><strong style="font-size: 18;">Задача 8: Трекер комбо-серии игрока</strong></summary>

Создайте консольное приложение, моделирующее работу **тракера комбо-серии**, который реагирует на изменение текущей серии попаданий и на достижение значимых «рубежей» комбо.

---

### Цель

Проверить умение:

1. Объявлять собственные делегаты с конкретным типом источника.
2. Создавать и вызывать обычные события.
3. Реализовывать кастомные события через `add` / `remove`.
4. Подписывать и отписывать разные обработчики.
5. Корректно вызывать события в нужный момент.

---

### Описание логики

Приложение моделирует серию игровых шагов, на каждом из которых либо увеличивается комбо (успешное попадание), либо комбо сбрасывается (получен урон/промах):

1. **Обычное событие** `StreakChanged` — вызывается при каждом изменении длины комбо.

   * Использует **собственный делегат** `ComboEventHandler`, принимающий:

     * экземпляр трекера `ComboTracker sender`;
     * текущее значение серии `int streak`.
   * Событие объявляется в виде:

     ```csharp
     public event ComboEventHandler? StreakChanged;
     ```

2. **Кастомное событие** `MilestoneReached` — возникает при достижении рубежей серии: 10, 20, 30 и т. д.

   * Реализуется вручную через `add` и `remove`.
   * Тип делегата `EventHandler<int>`; в аргумент передаётся достигнутый рубеж.
   * Подписчики хранятся во внутреннем экземпляре делегата (одна переменная-делегат).
   * При добавлении или удалении подписчика в консоль выводится сообщение (“подписчик добавлен / удалён”).
   * Если за один шаг пересекается несколько рубежей (например, с 19 до 31) — событие вызывается для каждого пересечённого рубежа.

---

### Требования к классам

**1. Класс `ComboTracker`**

* Объявляет собственный делегат:

  ```csharp
  public delegate void ComboEventHandler(ComboTracker sender, int streak);
  ```
* Содержит два события:

  * `StreakChanged` — обычное событие, использующее этот делегат.
  * `MilestoneReached` — кастомное событие с типом `EventHandler<int>`, реализованное через `add`/`remove` и внутренний делегат.
* Имеет метод `Start()`, который:

  * генерирует 12–16 игровых шагов; на каждом шаге с вероятностью примерно 70% серия увеличивается на 1–3, иначе — сбрасывается в 0;
  * после каждого шага вызывает `StreakChanged`;
  * при достижении новых рубежей 10/20/30/... вызывает `MilestoneReached` для каждого из них.

**2. Класс `ConsoleAnnouncer`**

* Подписывается на оба события.
* При каждом изменении выводит строку вида: “Комбо: 7”.
* При достижении рубежа выводит сообщение: “Рубеж комбо: 20! Держи темп!”

**3. Класс `StreakStats`**

* Подписывается только на событие `StreakChanged`.
* Подсчитывает:

  * сколько раз серия была сброшена в 0;
  * максимальную достигнутую длину комбо.
* Имеет метод `Report()`, который после завершения работы выводит, например:
  “Сбросов: 5; Максимальное комбо: 23”.

---

### Поведение программы

1. Программа создаёт экземпляр `ComboTracker`.
2. Создаёт двух подписчиков: `ConsoleAnnouncer` и `StreakStats`.
3. Подписывает их обработчики на соответствующие события.
4. Запускает симуляцию методом `Start()`.
5. После завершения отписывает один из обработчиков (например, `ConsoleAnnouncer` от `MilestoneReached`).
6. Вызывает у `StreakStats` метод `Report()`.

---

### Ожидаемый результат

При запуске программа должна:

* выводить текущую длину комбо после каждого шага;
* сообщать о достижении рубежей 10/20/30/...;
* в конце показывать число сбросов и максимальную длину комбо.

</details>
