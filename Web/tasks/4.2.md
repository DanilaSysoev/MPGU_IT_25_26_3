## Web 4.2 Декораторы С параметрами на python (максимальный балл 4, дедлай 30.09.2025 включительно)

### 1) Логирование с уровнем и префиксом

**Задание:** Реализуйте `log_with(level="INFO", prefix="")`, который перед вызовом печатает строку
`<level> <prefix><имя>(args, kwargs)` и после — `RET: <repr результата>`.

**Пример:**

```python
@log_with(level="DEBUG", prefix="[calc] ")
def add(a, b):
    return a + b

print(add(2, b=3))
# DEBUG [calc] add( (2,), {'b': 3} )
# RET: 5
```

---

### 2) Замер времени с меткой

**Задание:** `timeit(label="")` измеряет время выполнения и печатает
`TIME: <label or имя> took <milliseconds> ms`.

**Пример:**

```python
@timeit(label="heavy_sum")
def work():
    return sum(range(50_000))

print(work())
# TIME: heavy_sum took 3.45 ms
```

---

### 3) Повтор результата несколько раз

**Задание (новое, попроще):** `repeat(n)` вызывает функцию один раз, но возвращает список из `n` копий результата.

**Пример:**

```python
@repeat(3)
def hello():
    return "hi"

print(hello())  # ["hi", "hi", "hi"]
```

---

### 4) Повтор с параметрами

**Задание:** `retry(times=3, exceptions=(Exception,), delay=0.0)` повторяет вызов при указанных исключениях. Между попытками — `time.sleep(delay)`.

**Пример:**

```python
i = 0

@retry(times=4, exceptions=(ValueError,), delay=0.05)
def flaky():
    global i
    i += 1
    if i < 3:
        raise ValueError("not yet")
    return "ok"

print(flaky())  # ok
```

---

### 5) Проверка типов позиционных аргументов

**Задание:** `require_arg_types(*types_)` проверяет, что каждый позиционный аргумент соответствует типу по индексу. Если длина `args` не совпадает с количеством `types_` — `TypeError`.

**Пример:**

```python
@require_arg_types(int, str, float)
def pack(a, b, c):
    return a, b, c

print(pack(1, "x", 2.5))   # (1, 'x', 2.5)
print(pack("1", "x", 2.5)) # TypeError
```

---

### 6) Ограничение результата по диапазону

**Задание:** `clamp_result(min_value=None, max_value=None)` ограничивает числовой результат:

* если `min_value` не `None` и результат меньше — вернуть `min_value`;
* если `max_value` не `None` и результат больше — вернуть `max_value`;
* если оба `None` — вернуть как есть.

**Пример:**

```python
@clamp_result(min_value=0, max_value=100)
def score(raw):
    return raw

print(score(-5))    # 0
print(score(150))   # 100
print(score(42))    # 42
```

---

### 7) Лимит частоты вызовов

**Задание:** `rate_limit(calls, per_seconds)` разрешает не более `calls` вызовов за `per_seconds`. При превышении — `RuntimeError`.

**Пример:**

```python
@rate_limit(calls=2, per_seconds=1.0)
def ping():
    return "pong"

print(ping()); print(ping())  # ок
print(ping())                 # RuntimeError
```

---

### 8) Декоратор «дебаунс»

**Задание:** `debounce(wait_seconds)` — если повторный вызов пришёл раньше, чем прошло `wait_seconds` с предыдущего, подождать оставшееся время и только затем выполнить.

**Пример:**

```python
@debounce(0.2)
def action():
    print("done")

action(); action(); action()  # будут паузы ≥ 0.2s
```

---

### 9) Проверка роли/разрешений

**Задание:** `require_role(*allowed_roles)` проверяет глобальную переменную `CURRENT_ROLE` и разрешает вызов только если она в списке.

**Пример:**

```python
CURRENT_ROLE = "user"

@require_role("admin", "moderator")
def drop_table():
    return "dropped"

print(drop_table())  # RuntimeError

CURRENT_ROLE = "admin"
print(drop_table())  # "dropped"
```

---

### 10) Ограничение длины результата (новое, попроще)

**Задание:** `limit_length(max_len)` проверяет, что результат функции — строка. Если она длиннее `max_len`, обрезает и добавляет `"..."`.

**Пример:**

```python
@limit_length(10)
def get_text():
    return "This is a very long string"

print(get_text())  # "This is a ..."
```
