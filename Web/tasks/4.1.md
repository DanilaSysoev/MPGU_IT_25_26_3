## Web 4.1 Декораторы без параметров на python (максимальный балл 4, дедлай 30.09.2025 включительно)

### 1) Логирование вызова

**Задание:** Напишите декоратор `log_call`, который перед выполнением функции печатает `CALL: <имя>(args, kwargs)`, а после — `RET: <repr результата>`. Возвращаемое значение не изменяйте.

**Пример:**

```python
@log_call
def add(a, b):
    return a + b

print(add(2, 3))
# CALL: add(2, 3, {})
# RET: 5
# 5
```

---

### 2) Замер времени выполнения

**Задание:** Декоратор `timeit` измеряет время выполнения функции и печатает `TIME: <имя> took <milliseconds> ms`. На результат функции не влияет.

**Подсказка:** используйте `time.perf_counter()` до и после вызова, разницу умножьте на `1000`.

**Пример:**

```python
@timeit
def work():
    total = 0
    for i in range(10_000):
        total += i
    return total

print(work())
# TIME: work took 1.23 ms
# 49995000
```

---

### 3) Кеширование для функции с одним целым параметром

**Задание:** Декоратор `cache_int_arg` кеширует результат функции, у которой **ровно один позиционный параметр `n: int`**. Ключ кеша — значение `n`. Повторный вызов с тем же `n` не должен выполнять исходную функцию повторно.

**Пример:**

```python
@cache_int_arg
def fib(n):
    if n < 2: 
        return n
    return fib(n-1) + fib(n-2)

print(fib(10))   # первый вызов считает
print(fib(10))   # второй вызов берётся из кеша
```

---

### 4) Выполнить только один раз

**Задание:** Декоратор `run_once` выполняет функцию только при первом вызове; далее возвращает сохранённый первый результат, не вызывая функцию.

**Пример:**

```python
calls = 0

@run_once
def init():
    global calls
    calls += 1
    return "ready"

print(init())   # ready
print(init())   # ready (результат из памяти)
print(calls)    # 1
```

---

### 5) Подсчёт вызовов через атрибут

**Задание:** Декоратор `count_calls` добавляет к функции атрибут `calls` (int), который увеличивается на 1 при каждом вызове.

**Пример:**

```python
@count_calls
def greet(name):
    return f"Hello, {name}!"

print(greet("Danila"))
print(greet("World"))
print(greet.calls)  # 2
```

---

### 6) Проверка типов позиционных аргументов на `int`

**Задание:** Декоратор `enforce_ints` проверяет, что **каждый позиционный аргумент** (`*args`) — целое число; иначе поднимает `TypeError`. Именованные аргументы не проверяются.

**Подсказка:** используйте `isinstance(x, int)` для каждого аргумента в `args`.

**Пример:**

```python
@enforce_ints
def mul(a, b):
    return a * b

print(mul(2, 5))    # 10
print(mul(2, "5"))  # TypeError
```

---

### 7) Повтор с фиксированным количеством попыток (3)

**Задание:** Декоратор `retry3` перезапускает функцию до 3 раз при исключении; при успехе возвращает результат, при трёх неудачах пробрасывает последнее исключение.

**Пример:**

```python
i = 0

@retry3
def flaky():
    global i
    i += 1
    if i < 3:
        raise ValueError("fail")
    return "success"

print(flaky())  # success (после нескольких попыток)
```

---

### 8) Запрет именованных аргументов

**Задание:** Декоратор `no_kwargs` запрещает вызывать функцию с именованными аргументами. Если `kwargs` не пуст, поднимайте `TypeError`.

**Пример:**

```python
@no_kwargs
def square(x):
    return x * x

print(square(4))        # 16
print(square(x=4))      # TypeError
```

---

### 9) Запрет вызова при глобальном флаге

**Задание:** Используйте глобальный флаг `DISABLED = False`. Декоратор `disabled_if_flag` при `DISABLED is True` поднимает `RuntimeError("Feature disabled")`, иначе выполняет функцию.

**Пример:**

```python
DISABLED = False

@disabled_if_flag
def work():
    return "done"

print(work())   # done

DISABLED = True
print(work())   # RuntimeError: Feature disabled
```

---

### 10) Фиксированная задержка перед выполнением

**Задание:** Декоратор `delay_100ms` добавляет задержку \~100 мс перед вызовом функции. На результат не влияет.

**Подсказка:** используйте `time.sleep(0.1)`.

**Пример:**

```python
@delay_100ms
def hello():
    return "Hello after delay"

print(hello())
# (ждёт ~0.1 секунды)
# Hello after delay
```
